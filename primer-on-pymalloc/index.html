<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.9.1"/><style data-href="/blog/styles.ef2585c1540b47f18ca5.css" data-identity="gatsby-global-css">body{font-family:Open Sans;font-size:16px;min-height:100vh}</style><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="true"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&amp;display=swap"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"/><title data-gatsby-head="true">A primer on pymalloc | adamantmc</title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="sc-jTQDJr gkjNNp"><div class="sc-guDMob hXLPjk"><header class="sc-beyTiQ efyWMT">adamantmc</header><nav><ul class="sc-dmyDmy cEaNiF"><li class="sc-hLQTFJ bkEBvg"><a href="/blog/">Home</a></li><li class="sc-hLQTFJ bkEBvg"><a href="/blog/about/">About</a></li></ul></nav><button class="sc-eDLKEg inKBjG"><svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 384 512" fill="#4c566a"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg></button></div><main><h1 class="sc-gLLuHO hqHEwQ">A primer on pymalloc</h1><p class="sc-iBdoyZ fTpiHd">September 30, 2023 - 7 min read</p><div class="sc-fsYfxw ieiWED"><h2>TL;DR</h2>
<blockquote>
<p>Python uses <code>pymalloc</code> for small (&lt; 512 bytes) objects. Pymalloc requests memory in chunks called Arenas, which are 256KB each. An Arena is only freed only if all objects that are allocated on it are deleted. So allocating 1.000.000 objects of 512 bytes, totaling 512MB and deleting half of them does not mean that half of the memory (256MB) will be freed and returned to the OS.</p>
</blockquote>
<h1>Intro</h1>
<p>Say you have a big tree. Suddenly you realize that some of the nodes can be pruned so as to reduce memory. You prune the nodes, but the memory usage remains largely the same, if not unaffected. What gives?</p>
<h2>Background</h2>
<p>The tree in question is a Trie Tree. A Trie Tree, also known as a Prefix Tree, is a data structure for string lookups, which can be also used for prefix searches.</p>
<p>The words <code>dart</code>, <code>dance</code>, <code>dancer</code> and <code>danger</code> are stored in a Trie Tree as follows:</p>
<pre><code>root ─ d ─ a ─ r ─ t (dart)
       │
       └─ n ─ c ─ e (dance)
          │       └─ r (dancer)
          └─ g ─ e ─ r (danger)
</code></pre>
<p>Each letter is a node, and it points to the next letter. All leaf nodes are in fact words, and there exists a single path from the root to them. This can be also true for non-leaf nodes, in case a word is a prefix of another (e.g. <code>dance</code> and <code>dancer</code>).</p>
<p>This kind of tree supports use cases where we want to fetch all keys that start with a certain prefix. For example, say we want to search for all words that begin with &#x27;dan&#x27;. This query would be executed as follows:</p>
<pre><code class="language-python">node = root
for char in query:
    # find child node for given character
    next_node = node.get_child(char)

    if next_node is None:
        # If we can&#x27;t find the character, collect and return all words under the current node with a traversal (e.g. depth-first search)
        return collect_words_under_node(node)
    else:
        # else just step over to the next node and continue the loop
        node = next_node
</code></pre>
<p>For <code>dan</code>, we would stop at node <code>n</code> and return the words <code>dance</code>, <code>dancer</code> and <code>danger</code>. For a different query (e.g. <code>dab</code>), we can stop at node <code>a</code> and return
the words <code>dart</code>, <code>dance</code>, <code>dancer</code> and <code>danger</code> (or even return an error if we don&#x27;t want to allow searches using prefixes that are not in our tree).</p>
<p>Now if we wanted to reduce the memory footprint of such a tree, we could try compressing the paths. There are certain nodes that are only part of paths and have no extra information. These can be bundled together, so as to avoid the memory overhead of each node.</p>
<p>The initial idea was to do this as a <strong>post-processing step</strong>. So the tree is generated as above, and after it is generated, we:</p>
<ol>
<li>Start from the root node</li>
<li>For each node <code>a</code>
<ol>
<li>If <code>a</code> has a single child named <code>b</code>, replace <code>a</code> and <code>b</code> with a single node <code>ab</code></li>
<li>Repeat for <code>ab</code></li>
</ol>
</li>
</ol>
<p>Compressing the tree above would yield the following:</p>
<pre><code>root ─ da ─ rt (dart)
        │
        └─ n ─ ce (dance)
           │    └─ r (dancer)
           └─ ger (danger)
</code></pre>
<p>In this case, we went from 11 nodes in the original tree down to 7 nodes. Not bad - we removed ~42% of the original nodes. But did the memory usage also reduce by a proportional amount?</p>
<h2>The problem</h2>
<p>Well, no. That&#x27;s where Python&#x27;s <code>pymalloc</code> comes into play.</p>
<p>Python uses its own memory allocator called <code>pymalloc</code> for small (&lt; 512 bytes) objects. It works by reserving chunks of 256KB of memory called Arenas, and fitting these small objects in those chunks <sup>[<a href="https://docs.python.org/3/c-api/memory.html#the-pymalloc-allocator">1</a>]</sup> (<em>oversimplification - Arenas are organized into pools which are organized into blocks, but for the sake of this post, we&#x27;ll consider an Arena to be just a chunk of memory</em>).</p>
<p>The catch here is that an Arena is freed and given back to the OS only when it&#x27;s emptied. So even if we delete some of these small objects, we cannot be sure if their memory is given back to the OS, as we don&#x27;t know if we cleared an Arena.</p>
<p>Here&#x27;s an over-simplified example - let&#x27;s say we have 12 nodes, which made it into 3 Arenas, like so:</p>
<pre><code>|=========|=========|=========|
| Node 1  | Node 6  | Node 11 |
| Node 2  | Node 7  | Node 12 |
| Node 3  | Node 8  |         |
| Node 4  | Node 9  |         |
| Node 5  | Node 10 |         |
|---------|---------|---------|
| Arena 1 | Arena 2 | Arena 3 |
|=========|=========|=========|
</code></pre>
<p>Let&#x27;s say that after compression, we&#x27;ve removed nodes 2, 3, 4, 7, 8, 11 and 12. We end up with the following memory allocation:</p>
<pre><code>|=========|=========|=========|
| Node 1  | Node 6  |         |
|         |         |         |
|         |         |         |
|         | Node 9  |         |
| Node 5  | Node 10 |         |
|---------|---------|---------|
| Arena 1 | Arena 2 | Arena 3 |
|=========|=========|=========|
</code></pre>
<p>In this example, we&#x27;ve removed 7 nodes out of 12, which is about 58%. We would naively expect that 58% of our memory is freed, but since only Arena 3 is emptied, we&#x27;ll only see a 33% decrease in memory usage. If a single node was left in Arena 3, we would see no difference in memory usage.</p>
<h2>How to spot this issue</h2>
<p>We can use <code>sys._debugmallocstats()</code> to get some info about the memory usage. This function prints various memory usage metrics, and among other things the number of currently allocated arenas:</p>
<pre><code>...
# arenas allocated total   = 106
# arenas reclaimed         =  73
# arenas highwater mark    = 106
# arenas allocated current =  33
...
</code></pre>
<p>This tells us that:</p>
<ol>
<li>106 arenas have been allocated so far</li>
<li>73 of them have been freed (reclaimed)</li>
<li>106 arenas were used at any point in time</li>
<li>33 arenas are used now</li>
</ol>
<p>Here&#x27;s a script that performs the following experiment:</p>
<ol>
<li>Print memory stats</li>
<li>Store 1.000.000 strings and print memory stats</li>
<li>Remove strings based on probability and print memory stats</li>
</ol>
<pre><code class="language-python">import random
import sys
import gc

print(&quot;Startup memory stats&quot;)
sys._debugmallocstats()

strings = []
for i in range(1000000):
    strings.append(str(random.random()))

print(f&quot;{len(strings)} strings allocated memory stats&quot;)
sys._debugmallocstats()

p = 0.5
# Keep some of the strings based on a given probability
strings = [s for s in strings if random.random() &lt; p]

# Try to force cleanup of these strings, since they are not referenced anywhere else
gc.collect()

print(f&quot;{len(strings)} strings allocated memory stats&quot;)
sys._debugmallocstats()
</code></pre>
<p>Here&#x27;s what was printed after running this script with Python3.11.</p>
<p>Startup stats:</p>
<pre><code># arenas allocated total   = 2
# arenas reclaimed         = 0
# arenas highwater mark    = 2
# arenas allocated current = 2
</code></pre>
<p>1 million strings allocated stats:</p>
<pre><code># arenas allocated total   = 80
# arenas reclaimed         = 0
# arenas highwater mark    = 80
# arenas allocated current = 80
</code></pre>
<p>~500k strings allocated stats (after removing ~500k strings randomly):</p>
<pre><code># arenas allocated total   = 80
# arenas reclaimed         = 0
# arenas highwater mark    = 80
# arenas allocated current = 80
</code></pre>
<p>No arenas have been reclaimed. That&#x27;s expected - sampling at random would yield something close to picking the same amount of strings out of every arena, so we don&#x27;t expect any of them to be empty.</p>
<p>And if we reduce <code>p</code> (probability with which we keep a string) to 0.00005, where we end up with 50 strings, we get the following allocation stats:</p>
<pre><code># arenas allocated total    = 80
# arenas reclaimed          = 41
# arenas highwater mark     = 80
# arenas allocated current  = 39
</code></pre>
<p>Again, since we&#x27;re using random sampling to remove strings, it makes sense that most of the arenas won&#x27;t be emptied. Same behavior as above, but since we cleared many more strings, we do see a drop in currently allocated arenas.</p>
<p>On the other hand, if we just keep the first 500k strings (<code>strings = strings[:500000]</code>), we end up cleaning almost half of the arenas:</p>
<pre><code># arenas allocated total   = 80
# arenas reclaimed         = 37
# arenas highwater mark    = 80
# arenas allocated current = 43
</code></pre>
<p>This is expected, as the last-allocated arenas most probably contain the last-generated strings. In other words, we&#x27;re assuming that the first allocated Arena will contain the first X strings, while the last allocated Arena will contain the last X strings (where X is the number of strings that can fit in an Arena).</p>
<p>So deleting the last 500k strings means that we&#x27;re probably clearing whole arenas, as they were probably stored next to each other.</p>
<h2>Is this a Python problem?</h2>
<p>Well, pymalloc is a Python construct, but generally speaking, memory fragmentation is not something that happens only in Python. It&#x27;s something unavoidable, but manageable when you can control how memory is allocated. It&#x27;s the kind of problem that makes perfect sense as to why it happens, but you only think of it when you stumble upon it.</p>
<h2>Is there a solution?</h2>
<p>There&#x27;s not a single solution per se; in fact, the only way to make sure that we don&#x27;t have half-empty arenas is to never allocate so many of them in the first place.</p>
<p>In this example, this means that we cannot create X nodes and delete Y of them down the road - we either have to create only Y nodes, or find a different solution like creating all X nodes, deleting some of them, writing the tree to disk in some format and re-reading it in a way that we only create Y nodes.</p>
<h3>Further reading / references:</h3>
<h4><a href="https://stackoverflow.com/a/3770572">https://stackoverflow.com/a/3770572</a></h4>
<h4><a href="https://docs.python.org/3/c-api/memory.html#the-pymalloc-allocator">https://docs.python.org/3/c-api/memory.html#the-pymalloc-allocator</a></h4>
<h4><a href="https://www.evanjones.ca/memoryallocator/">https://www.evanjones.ca/memoryallocator/</a></h4>
<h4><a href="https://stackoverflow.com/a/40663945">https://stackoverflow.com/a/40663945</a></h4></div></main></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/primer-on-pymalloc/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-904696afa8afd3dddddb.js\"],\"component---src-pages-404-js\":[\"/component---src-pages-404-js-d72c0e7ab86464795ded.js\"],\"component---src-pages-about-js\":[\"/component---src-pages-about-js-e0acc6245baf00d1b8ce.js\"],\"component---src-pages-index-js\":[\"/component---src-pages-index-js-202621b25c82d85776c3.js\"],\"component---src-pages-mdx-frontmatter-slug-js-content-file-path-blog-pymalloc-mdx\":[\"/component---src-pages-mdx-frontmatter-slug-js-content-file-path-blog-pymalloc-mdx-a27c9f8c4ba3208d15c3.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="372c73cb6c6a1d4b77a4";</script><script src="/blog/webpack-runtime-1cab5a57498bc8675706.js" async></script><script src="/blog/framework-9649dcfd1ddbf692b0b9.js" async></script><script src="/blog/app-904696afa8afd3dddddb.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>